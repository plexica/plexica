# M2.4 - Plugin Registry & Marketplace

**Milestone Duration**: 4 weeks (Weeks 13-16)  
**Status**: ğŸŸ¡ Ready to Start  
**Priority**: ğŸ”¥ Critical  
**Owner**: Backend (1) + Frontend (2)  
**Estimated Hours**: 160h total  
**Dependencies**: M2.1 âœ…, M2.2 âœ…, M2.3 âœ…  
**Start Date**: January 24, 2026  
**Target Completion**: February 20, 2026

---

## Objectives

1. Build comprehensive plugin registry API with search and discovery
2. Implement plugin publishing workflow with validation and security scanning
3. Create marketplace UI for both Super Admin and Tenant applications
4. Add plugin versioning system with semantic versioning enforcement
5. Enable one-click plugin installation from registry
6. Implement review and rating system for published plugins
7. Create analytics dashboard for marketplace metrics

---

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Plugin Registry & Marketplace                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Registry API Service (Core API)              â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  â€¢ Plugin Registry (CRUD + Search)                   â”‚  â”‚
â”‚  â”‚  â€¢ Version Management (Publishing Workflow)          â”‚  â”‚
â”‚  â”‚  â€¢ Review & Rating System                            â”‚  â”‚
â”‚  â”‚  â€¢ Publishing API (Upload + Validation + Scanning)   â”‚  â”‚
â”‚  â”‚  â€¢ Analytics Service (Metrics + Reporting)           â”‚  â”‚
â”‚  â”‚  â€¢ Webhook System (Event Publishing)                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                      â†“                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Registry Database (PostgreSQL)               â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  â€¢ PluginRegistry                                    â”‚  â”‚
â”‚  â”‚  â€¢ PluginVersion                                     â”‚  â”‚
â”‚  â”‚  â€¢ PluginReview                                      â”‚  â”‚
â”‚  â”‚  â€¢ PublishingSession                                 â”‚  â”‚
â”‚  â”‚  â€¢ RegistryAnalytics                                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                      â†“                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         External Services                            â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  â€¢ Docker Registry (Backend Images)                  â”‚  â”‚
â”‚  â”‚  â€¢ CDN / MinIO (Frontend Bundles)                    â”‚  â”‚
â”‚  â”‚  â€¢ ClamAV (Virus Scanning)                           â”‚  â”‚
â”‚  â”‚  â€¢ Snyk (Security Scanning)                          â”‚  â”‚
â”‚  â”‚  â€¢ Container Registry (Docker Hub / Private)         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                      â†“                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Frontend Marketplaces (Super Admin + Tenant)        â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  â€¢ Browse & Discovery                                â”‚  â”‚
â”‚  â”‚  â€¢ Search with Autocomplete                          â”‚  â”‚
â”‚  â”‚  â€¢ Plugin Detail Pages                               â”‚  â”‚
â”‚  â”‚  â€¢ Install Wizard                                    â”‚  â”‚
â”‚  â”‚  â€¢ Review & Rating                                   â”‚  â”‚
â”‚  â”‚  â€¢ Analytics Dashboard (Super Admin)                 â”‚  â”‚
â”‚  â”‚  â€¢ Publishing Management (Super Admin)               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Week 13: Registry API & Database (40h)

### Task 13.1: Registry Data Model (16h)

**Goal**: Design and implement database schema for plugin registry

**Files to Create/Modify**:

- `packages/database/prisma/schema.prisma` - Add registry models

**Implementation**:

```prisma
// File: packages/database/prisma/schema.prisma

model PluginRegistry {
  id            String   @id @default(uuid()) @db.Uuid
  pluginId      String   @unique
  name          String   @db.VarChar(255)
  slug          String   @unique
  description   String   @db.Text
  longDescription String? @db.Text
  category      String   @db.VarChar(100)
  author        String   @db.VarChar(255)
  authorEmail   String?  @db.VarChar(255)
  authorUrl     String?
  repositoryUrl String?
  licenseType   String   @db.VarChar(50)
  licenseUrl    String?
  iconUrl       String?
  bannerUrl     String?

  // Metadata
  featured      Boolean  @default(false)
  verified      Boolean  @default(false)
  featured_at   DateTime?
  verified_at   DateTime?

  // Ratings & Reviews
  rating        Float    @default(0)
  reviewCount   Int      @default(0)
  downloadCount Int      @default(0)
  installCount  Int      @default(0)

  // Categorization
  tags          String[] @default([])
  keywords      String[] @default([])

  // Pricing
  pricing       Json? // { "type": "free|paid|freemium", "price": 0, "currency": "USD", "billingCycle": "monthly|yearly" }

  // Relations
  versions      PluginVersion[]
  reviews       PluginReview[]
  installedAt   PluginInstallation[]

  // Timestamps
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@index([category])
  @@index([featured])
  @@index([verified])
  @@index([rating])
  @@index([downloadCount])
  @@map("plugin_registry")
  @@schema("public")
}

model PluginVersion {
  id              String   @id @default(uuid()) @db.Uuid
  registryId      String   @db.Uuid
  version         String   @db.VarChar(50)
  releaseNotes    String?  @db.Text

  // Artifacts
  manifestUrl     String?  // URL to manifest.json
  backendImageUrl String?  // URL to backend Docker image
  backendImageTag String?  @db.VarChar(100)
  frontendBundleUrl String?  // URL to frontend bundle zip

  // Compatibility
  minCoreVersion  String   @db.VarChar(50)
  maxCoreVersion  String?  @db.VarChar(50)
  minNodeVersion  String   @db.VarChar(50)

  // Lifecycle
  deprecated      Boolean  @default(false)
  yanked          Boolean  @default(false)
  publishedAt     DateTime @default(now()) @map("published_at")
  deprecatedAt    DateTime?

  // Stats
  downloads       Int      @default(0)
  installs        Int      @default(0)

  // Security
  securityScanUrl String?
  securityScanned Boolean  @default(false)
  securityPassed  Boolean? // null=pending, true=passed, false=failed
  virusScanUrl    String?
  virusScanned    Boolean  @default(false)
  virusClean      Boolean? // null=pending, true=clean, false=infected

  // Relations
  registry        PluginRegistry @relation(fields: [registryId], references: [id], onDelete: Cascade)
  installations   PluginInstallation[]

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@unique([registryId, version])
  @@index([registryId])
  @@index([deprecated])
  @@index([yanked])
  @@map("plugin_version")
  @@schema("public")
}

model PluginReview {
  id          String   @id @default(uuid()) @db.Uuid
  registryId  String   @db.Uuid
  userId      String   @db.Uuid
  tenantId    String   @db.Uuid

  // Review content
  rating      Int      @db.SmallInt // 1-5
  title       String?  @db.VarChar(255)
  comment     String?  @db.Text
  helpful_count Int    @default(0)

  // Moderation
  approved    Boolean  @default(true) // Tenant admin review
  flagged     Boolean  @default(false)
  hidden      Boolean  @default(false)

  // Relations
  registry    PluginRegistry @relation(fields: [registryId], references: [id], onDelete: Cascade)
  user        User @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant      Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@unique([registryId, userId, tenantId]) // One review per user per plugin per tenant
  @@index([registryId])
  @@index([userId])
  @@index([tenantId])
  @@map("plugin_review")
  @@schema("public")
}

model PluginInstallation {
  id          String   @id @default(uuid()) @db.Uuid
  registryId  String   @db.Uuid
  versionId   String   @db.Uuid
  tenantId    String   @db.Uuid
  installedBy String   @db.Uuid

  // Status
  status      String   @db.VarChar(50) // "installing", "active", "disabled", "failed"
  errorMessage String? @db.Text

  // Configuration
  configuration Json?

  // Timestamps
  installedAt DateTime @default(now()) @map("installed_at")
  disabledAt  DateTime?
  uninstalledAt DateTime?

  // Relations
  registry    PluginRegistry @relation(fields: [registryId], references: [id])
  version     PluginVersion @relation(fields: [versionId], references: [id])
  tenant      Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user        User @relation(fields: [installedBy], references: [id])

  @@unique([registryId, tenantId]) // One active installation per tenant
  @@index([registryId])
  @@index([tenantId])
  @@index([status])
  @@map("plugin_installation")
  @@schema("public")
}

model PublishingSession {
  id              String   @id @default(uuid()) @db.Uuid
  publisherId     String   @db.Uuid
  pluginId        String   @db.VarChar(255)
  version         String   @db.VarChar(50)

  // Session state
  status          String   @db.VarChar(50) // "initiated", "backend_uploaded", "frontend_uploaded", "scanning", "approval_pending", "approved", "published", "rejected"

  // Upload URLs
  backendUploadUrl String?
  frontendUploadUrl String?

  // Artifacts
  backendImagePath String?
  frontendBundlePath String?
  manifestPath    String?

  // Scanning
  securityScanStarted DateTime?
  securityScanCompleted DateTime?
  securityScanResult Json?

  virusScanStarted DateTime?
  virusScanCompleted DateTime?
  virusScanResult  Json?

  // Approval
  approvalNotes   String? @db.Text
  approvedBy      String? @db.Uuid
  approvedAt      DateTime?
  rejectionReason String? @db.Text

  // Relations
  publisher       User @relation(fields: [publisherId], references: [id])

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  expiresAt       DateTime @default(dbgenerated("now() + interval '7 days'"))
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@unique([pluginId, version])
  @@index([publisherId])
  @@index([status])
  @@map("publishing_session")
  @@schema("public")
}

model RegistryAnalytics {
  id              String   @id @default(uuid()) @db.Uuid
  registryId      String   @db.Uuid

  // Daily metrics
  date            DateTime @db.Date
  downloads       Int      @default(0)
  installs        Int      @default(0)
  uninstalls      Int      @default(0)
  newReviews      Int      @default(0)
  avgRating       Float    @default(0)

  // Engagement
  views           Int      @default(0)
  detailViews     Int      @default(0)
  installAttempts Int      @default(0)

  // Trends
  rating          Float    @default(0) // Snapshot at date
  reviewCount     Int      @default(0)

  // Relations
  registry        PluginRegistry @relation(fields: [registryId], references: [id], onDelete: Cascade)

  @@unique([registryId, date])
  @@index([registryId])
  @@index([date])
  @@map("registry_analytics")
  @@schema("public")
}
```

**Tasks**:

1. Add all 6 models to `schema.prisma`
2. Add appropriate indexes for performance (search, filtering, sorting)
3. Create migration file
4. Validate schema with `pnpm db:validate`

**Deliverables**:

- âœ… PluginRegistry model with all required fields
- âœ… PluginVersion model with versioning support
- âœ… PluginReview model with ratings
- âœ… PluginInstallation model for tracking installs
- âœ… PublishingSession for upload workflows
- âœ… RegistryAnalytics for metrics
- âœ… Migration script

**Estimated Time**: 8h

---

### Task 13.2: Seed Initial Plugins (8h)

**Goal**: Create seed data for development and testing

**Files to Create**:

- `packages/database/prisma/seeds/registry-plugins.ts`

**Implementation Plan**:

1. Create 5-10 sample plugins with metadata
2. Add multiple versions per plugin (to test versioning)
3. Add sample reviews (to test ratings)
4. Create different categories (productivity, communication, analytics, etc.)
5. Seed both free and paid plugins
6. Run seed script during development setup

**Sample Plugins**:

1. Sample Analytics (existing - update with registry data)
2. CRM Plugin (preview)
3. Communication Plugin (Slack integration)
4. Notification Hub
5. File Storage
6. API Gateway
7. Dashboard Builder
8. Report Generator

**Deliverables**:

- âœ… Seed script with 8+ plugins
- âœ… Multiple versions per plugin
- âœ… Sample reviews and ratings
- âœ… Diverse categories and pricing models

**Estimated Time**: 8h

---

### Task 13.3: Registry Search Service (16h)

**Goal**: Implement search and discovery functionality

**Files to Create/Modify**:

- `apps/core-api/src/modules/registry/registry.service.ts`
- `apps/core-api/src/modules/registry/registry-search.service.ts`
- `apps/core-api/src/controllers/registry.controller.ts`

**Implementation Plan**:

```typescript
// File: apps/core-api/src/modules/registry/registry.service.ts

@Injectable()
export class RegistryService {
  constructor(
    private prisma: PrismaService,
    private search: RegistrySearchService,
    private cache: CacheService
  ) {}

  // Basic CRUD
  async createRegistry(data: CreateRegistryDTO): Promise<PluginRegistry> {
    // Validate plugin doesn't already exist
    const existing = await this.prisma.pluginRegistry.findUnique({
      where: { pluginId: data.pluginId },
    });
    if (existing) throw new ConflictException('Plugin already registered');

    // Create registry entry
    const registry = await this.prisma.pluginRegistry.create({
      data: {
        pluginId: data.pluginId,
        name: data.name,
        slug: this.generateSlug(data.name),
        description: data.description,
        category: data.category,
        author: data.author,
        authorEmail: data.authorEmail,
        tags: data.tags || [],
        pricing: data.pricing || { type: 'free' },
      },
    });

    // Invalidate cache
    await this.cache.del('registry:plugins:*');

    return registry;
  }

  async getRegistry(pluginId: string): Promise<PluginRegistry | null> {
    return this.cache.get(`registry:${pluginId}`, async () =>
      this.prisma.pluginRegistry.findUnique({
        where: { pluginId },
        include: { versions: true, reviews: true },
      })
    );
  }

  async updateRegistry(pluginId: string, data: UpdateRegistryDTO): Promise<PluginRegistry> {
    const registry = await this.prisma.pluginRegistry.update({
      where: { pluginId },
      data,
    });

    await this.cache.del(`registry:${pluginId}`);

    return registry;
  }

  async deleteRegistry(pluginId: string): Promise<void> {
    await this.prisma.pluginRegistry.delete({
      where: { pluginId },
    });

    await this.cache.del(`registry:${pluginId}`);
  }

  // Search with full-text and fuzzy matching
  async searchPlugins(
    query: string,
    filters: SearchFilters,
    page: number = 1,
    limit: number = 20
  ): Promise<PaginatedResult<PluginRegistry>> {
    return this.search.search(query, filters, page, limit);
  }

  // Get plugin with versions
  async getPluginWithVersions(pluginId: string) {
    return this.prisma.pluginRegistry.findUnique({
      where: { pluginId },
      include: {
        versions: {
          where: { yanked: false },
          orderBy: { publishedAt: 'desc' },
        },
      },
    });
  }

  // Get specific version
  async getPluginVersion(pluginId: string, version: string) {
    return this.prisma.pluginVersion.findFirst({
      where: {
        registry: { pluginId },
        version,
        yanked: false,
      },
    });
  }

  // Featured plugins
  async getFeaturedPlugins(limit: number = 10) {
    return this.cache.get('registry:featured', async () =>
      this.prisma.pluginRegistry.findMany({
        where: {
          featured: true,
          verified: true,
        },
        take: limit,
        orderBy: { downloadCount: 'desc' },
      })
    );
  }

  // Category listing
  async getCategories() {
    return this.cache.get('registry:categories', async () => {
      const plugins = await this.prisma.pluginRegistry.groupBy({
        by: ['category'],
        _count: true,
        orderBy: { _count: { id: 'desc' } },
      });

      return plugins.map((p) => ({
        category: p.category,
        count: p._count,
      }));
    });
  }

  // Stats endpoint
  async getRegistryStats() {
    return {
      totalPlugins: await this.prisma.pluginRegistry.count(),
      totalDownloads: await this.prisma.pluginRegistry.aggregate({
        _sum: { downloadCount: true },
      }),
      averageRating: await this.prisma.pluginRegistry.aggregate({
        _avg: { rating: true },
      }),
      verifiedCount: await this.prisma.pluginRegistry.count({
        where: { verified: true },
      }),
      featuredCount: await this.prisma.pluginRegistry.count({
        where: { featured: true },
      }),
    };
  }

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-');
  }
}
```

```typescript
// File: apps/core-api/src/modules/registry/registry-search.service.ts

@Injectable()
export class RegistrySearchService {
  constructor(private prisma: PrismaService) {}

  async search(
    query: string,
    filters: SearchFilters,
    page: number = 1,
    limit: number = 20
  ): Promise<PaginatedResult<PluginRegistry>> {
    const offset = (page - 1) * limit;

    // Build search query with full-text search
    const whereConditions: Prisma.PluginRegistryWhereInput[] = [];

    if (query && query.trim()) {
      whereConditions.push({
        OR: [
          { name: { search: query } },
          { description: { search: query } },
          { tags: { has: query } },
          { author: { contains: query, mode: 'insensitive' } },
        ],
      });
    }

    // Apply filters
    if (filters.category) {
      whereConditions.push({ category: filters.category });
    }

    if (filters.verified !== undefined) {
      whereConditions.push({ verified: filters.verified });
    }

    if (filters.featured !== undefined) {
      whereConditions.push({ featured: filters.featured });
    }

    if (filters.minRating !== undefined) {
      whereConditions.push({ rating: { gte: filters.minRating } });
    }

    // Pricing filter
    if (filters.priceType) {
      whereConditions.push({
        pricing: {
          path: ['type'],
          equals: filters.priceType,
        },
      });
    }

    // Build final where clause
    const where: Prisma.PluginRegistryWhereInput =
      whereConditions.length > 0 ? { AND: whereConditions } : {};

    // Fetch results with sorting
    const [total, plugins] = await Promise.all([
      this.prisma.pluginRegistry.count({ where }),
      this.prisma.pluginRegistry.findMany({
        where,
        orderBy: this.buildOrderBy(filters.sort),
        skip: offset,
        take: limit,
        include: {
          versions: {
            where: { yanked: false },
            take: 1,
            orderBy: { publishedAt: 'desc' },
          },
        },
      }),
    ]);

    return {
      data: plugins,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
        hasNext: page < Math.ceil(total / limit),
        hasPrev: page > 1,
      },
    };
  }

  async getSearchSuggestions(query: string, limit: number = 10) {
    return this.prisma.pluginRegistry.findMany({
      where: {
        OR: [
          { name: { startsWith: query, mode: 'insensitive' } },
          { author: { startsWith: query, mode: 'insensitive' } },
        ],
      },
      select: { name: true, author: true },
      take: limit,
    });
  }

  private buildOrderBy(sort?: string): Prisma.PluginRegistryOrderByWithRelationInput {
    switch (sort) {
      case 'popular':
        return { downloadCount: 'desc' };
      case 'rating':
        return { rating: 'desc' };
      case 'newest':
        return { createdAt: 'desc' };
      case 'oldest':
        return { createdAt: 'asc' };
      default:
        return { downloadCount: 'desc' };
    }
  }
}
```

**Deliverables**:

- âœ… Registry service with CRUD operations
- âœ… Full-text search implementation
- âœ… Search filters (category, rating, pricing, verified)
- âœ… Sorting options (popular, rating, newest)
- âœ… Pagination support
- âœ… Search suggestions/autocomplete

**Estimated Time**: 8h

---

## Week 14: Plugin Publishing Workflow (40h)

### Task 14.1: Publishing API Endpoints (20h)

**Goal**: Implement API for plugin publishing and versioning

**Files to Create**:

- `apps/core-api/src/modules/registry/publishing.service.ts`
- `apps/core-api/src/controllers/publishing.controller.ts`

**Endpoints to Implement**:

1. `POST /api/registry/publish/initiate` - Start publishing session (20h effort includes all endpoints)
2. `POST /api/registry/publish/upload-backend` - Upload backend Docker image
3. `POST /api/registry/publish/upload-frontend` - Upload frontend bundle
4. `POST /api/registry/publish/complete` - Finalize and publish
5. `GET /api/registry/publish/sessions` - List user's publishing sessions
6. `GET /api/registry/publish/sessions/:sessionId` - Get session details
7. `POST /api/registry/publish/validate` - Validate manifest before publishing

**Implementation**:

```typescript
// File: apps/core-api/src/modules/registry/publishing.service.ts

interface PublishingValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

@Injectable()
export class PublishingService {
  constructor(
    private prisma: PrismaService,
    private storage: StorageService,
    private dockerRegistry: DockerRegistryService,
    private cdn: CDNService,
    private security: SecurityScanService
  ) {}

  async initiatePublishSession(
    userId: string,
    data: InitiatePublishDTO
  ): Promise<PublishingSession> {
    // Validate input
    const validation = await this.validateManifest(data.manifest);
    if (!validation.valid) {
      throw new BadRequestException(validation.errors);
    }

    // Check rate limiting (10 publishes/day per user)
    const dailyCount = await this.prisma.publishingSession.count({
      where: {
        publisherId: userId,
        createdAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1000),
        },
      },
    });

    if (dailyCount >= 10) {
      throw new ConflictException('Publishing rate limit exceeded (10/day)');
    }

    // Create publishing session
    const session = await this.prisma.publishingSession.create({
      data: {
        publisherId: userId,
        pluginId: data.pluginId,
        version: data.version,
        status: 'initiated',
        backendUploadUrl: await this.generateUploadUrl('backend'),
        frontendUploadUrl: await this.generateUploadUrl('frontend'),
      },
    });

    return session;
  }

  async uploadBackendImage(sessionId: string, imageData: Buffer): Promise<void> {
    const session = await this.getSession(sessionId);

    // Validate image
    await this.validateDockerImage(imageData);

    // Upload to storage
    const path = `plugins/${session.pluginId}/v${session.version}/backend.tar.gz`;
    await this.storage.upload(path, imageData);

    // Tag and push to registry
    const imageName = `plexica/${session.pluginId}:${session.version}`;
    await this.dockerRegistry.push(imageName, imageData);

    // Update session
    await this.prisma.publishingSession.update({
      where: { id: sessionId },
      data: {
        status: 'backend_uploaded',
        backendImagePath: path,
        backendImageTag: imageName,
      },
    });
  }

  async uploadFrontendBundle(sessionId: string, bundleData: Buffer): Promise<void> {
    const session = await this.getSession(sessionId);

    // Validate bundle
    await this.validateFrontendBundle(bundleData);

    // Upload to storage
    const path = `plugins/${session.pluginId}/v${session.version}/frontend.zip`;
    await this.storage.upload(path, bundleData);

    // Upload to CDN
    await this.cdn.deploy({
      pluginId: session.pluginId,
      version: session.version,
      data: bundleData,
    });

    // Update session
    await this.prisma.publishingSession.update({
      where: { id: sessionId },
      data: {
        status: 'frontend_uploaded',
        frontendBundlePath: path,
      },
    });
  }

  async completePublishing(sessionId: string): Promise<PluginRegistry> {
    const session = await this.getSession(sessionId);

    // Validate both uploads completed
    if (session.status !== 'frontend_uploaded') {
      throw new BadRequestException('Both backend and frontend must be uploaded');
    }

    // Start security scanning
    await this.startSecurityScans(session);

    // Update session status
    await this.prisma.publishingSession.update({
      where: { id: sessionId },
      data: { status: 'scanning' },
    });

    // Create or update plugin registry
    let registry = await this.prisma.pluginRegistry.findUnique({
      where: { pluginId: session.pluginId },
    });

    if (!registry) {
      registry = await this.prisma.pluginRegistry.create({
        data: {
          pluginId: session.pluginId,
          name: session.manifest.name,
          slug: this.generateSlug(session.manifest.name),
          description: session.manifest.description,
          category: session.manifest.category || 'other',
          author: session.manifest.author,
          authorEmail: session.manifest.authorEmail,
          tags: session.manifest.tags || [],
          pricing: session.manifest.pricing || { type: 'free' },
          iconUrl: session.manifest.iconUrl,
        },
      });
    }

    // Create version
    const version = await this.prisma.pluginVersion.create({
      data: {
        registryId: registry.id,
        version: session.version,
        releaseNotes: session.releaseNotes,
        manifestUrl: `${process.env.CDN_URL}/plugins/${session.pluginId}/v${session.version}/manifest.json`,
        backendImageUrl: `${process.env.DOCKER_REGISTRY}/${session.backendImageTag}`,
        frontendBundleUrl: `${process.env.CDN_URL}/plugins/${session.pluginId}/v${session.version}/`,
        minCoreVersion: session.manifest.minCoreVersion || '0.1.0',
      },
    });

    // Mark session as published
    await this.prisma.publishingSession.update({
      where: { id: sessionId },
      data: {
        status: 'published',
        approvedAt: new Date(),
      },
    });

    return registry;
  }

  async validateManifest(manifest: any): Promise<PublishingValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Required fields
    if (!manifest.pluginId) errors.push('pluginId is required');
    if (!manifest.name) errors.push('name is required');
    if (!manifest.description) errors.push('description is required');
    if (!manifest.version) errors.push('version is required');
    if (!manifest.author) errors.push('author is required');

    // Version format (semver)
    if (manifest.version && !this.isValidSemver(manifest.version)) {
      errors.push('version must follow semantic versioning (e.g., 1.0.0)');
    }

    // Optional fields
    if (!manifest.category) warnings.push('category not specified');
    if (!manifest.license) warnings.push('license type not specified');

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  private async startSecurityScans(session: PublishingSession): Promise<void> {
    // Start virus scan
    this.startVirusScan(session);

    // Start security scan (async, don't wait)
    this.startSecurityScan(session);
  }

  private async startVirusScan(session: PublishingSession): Promise<void> {
    // Would integrate with ClamAV or similar
    const result = await this.security.virusScan(session.backendImagePath);

    await this.prisma.publishingSession.update({
      where: { id: session.id },
      data: {
        virusScanned: true,
        virusClean: result.clean,
        virusScanUrl: result.reportUrl,
      },
    });
  }

  private async startSecurityScan(session: PublishingSession): Promise<void> {
    // Would integrate with Snyk or similar
    const result = await this.security.securityScan(session.backendImagePath);

    await this.prisma.publishingSession.update({
      where: { id: session.id },
      data: {
        securityScanned: true,
        securityPassed: !result.hasVulnerabilities,
        securityScanUrl: result.reportUrl,
      },
    });
  }

  private isValidSemver(version: string): boolean {
    return /^\d+\.\d+\.\d+(-[a-zA-Z0-9]+)?(\+[a-zA-Z0-9]+)?$/.test(version);
  }

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-');
  }

  private async getSession(sessionId: string): Promise<PublishingSession> {
    const session = await this.prisma.publishingSession.findUnique({
      where: { id: sessionId },
    });

    if (!session) {
      throw new NotFoundException('Publishing session not found');
    }

    return session;
  }

  private async generateUploadUrl(type: 'backend' | 'frontend'): Promise<string> {
    // Generate pre-signed URLs for uploads
    // Simplified - actual implementation would use storage provider APIs
    return `${process.env.API_URL}/api/registry/publish/upload-${type}?token=${this.generateToken()}`;
  }

  private generateToken(): string {
    return Math.random().toString(36).substring(7);
  }
}
```

**Deliverables**:

- âœ… Publishing API endpoints (7 endpoints)
- âœ… Version validation
- âœ… Rate limiting
- âœ… Upload handling
- âœ… Security scanning integration

**Estimated Time**: 20h

---

### Task 14.2: CLI Publishing Command (20h)

**Goal**: Implement `plexica-cli publish` command

**Files to Create**:

- `packages/cli/src/commands/publish.ts`
- `packages/cli/src/services/publishing-client.ts`

**Features**:

- Interactive mode with prompts
- Dry-run mode for testing
- CI/CD mode for automation
- Version auto-bumping
- Build integration
- Progress tracking

**Estimated Time**: 20h

---

## Week 15: Marketplace UI - Super Admin (40h)

### Task 15.1: Super Admin Marketplace Page (24h)

**Goal**: Build marketplace management UI for Super Admin

**Files to Create**:

- `apps/super-admin/src/pages/PluginRegistry.tsx` (~400 lines)
- `apps/super-admin/src/pages/PublishingQueue.tsx` (~300 lines)
- `apps/super-admin/src/components/PluginCard.tsx` (~150 lines)
- `apps/super-admin/src/components/PluginDetailModal.tsx` (~250 lines)
- `apps/super-admin/src/components/VersionHistoryTable.tsx` (~200 lines)

**Features**:

- Plugin list with filters and search
- Plugin approval workflow
- Featured plugin management
- Plugin verification
- Version yanking (remove from marketplace)
- Analytics view

**Estimated Time**: 24h

---

### Task 15.2: Marketplace Analytics (16h)

**Goal**: Create analytics dashboard for marketplace metrics

**Files to Create**:

- `apps/super-admin/src/pages/MarketplaceAnalytics.tsx` (~350 lines)
- `apps/super-admin/src/components/MarketplaceCharts.tsx` (~300 lines)

**Metrics**:

- Top plugins by downloads
- Top plugins by revenue
- Plugin growth trends
- Category distribution
- User engagement
- Geographic distribution

**Estimated Time**: 16h

---

## Week 16: Marketplace UI - Tenant App (40h)

### Task 16.1: Plugin Browse & Discovery (16h)

**Goal**: Build marketplace browsing UI for tenants

**Files to Create**:

- `apps/web/src/pages/Marketplace.tsx` (~500 lines)
- `apps/web/src/components/MarketplaceFilters.tsx` (~200 lines)
- `apps/web/src/components/PluginGrid.tsx` (~150 lines)

**Features**:

- Plugin grid/list view
- Category navigation
- Search with autocomplete
- Filters (price, rating, verified, features)
- Sort options
- Responsive design

**Estimated Time**: 16h

---

### Task 16.2: Plugin Detail & Installation (24h)

**Goal**: Plugin details page and installation wizard

**Files to Create**:

- `apps/web/src/pages/PluginDetail.tsx` (~400 lines)
- `apps/web/src/components/PluginInstallWizard.tsx` (~300 lines)
- `apps/web/src/components/ReviewForm.tsx` (~150 lines)

**Features**:

- Full plugin details
- Screenshots and documentation
- Review submission
- Installation wizard (5 steps)
- Version selector
- Related plugins

**Estimated Time**: 24h

---

## Success Criteria

### Functionality âœ…

- [ ] Plugin registry API operational with 11 endpoints
- [ ] Publishing workflow complete with validation
- [ ] Marketplace UI in Super Admin fully functional
- [ ] Marketplace UI in Tenant App fully functional
- [ ] Plugin installation from registry working
- [ ] Version management (create, yank, deprecate)
- [ ] Review and rating system working
- [ ] Search with filters and autocomplete
- [ ] Analytics dashboard populated

### Performance âœ…

- [ ] Registry search < 200ms
- [ ] Plugin installation < 60s
- [ ] Marketplace page load < 2s
- [ ] Search autocomplete < 100ms
- [ ] Category listing < 500ms

### Quality âœ…

- [ ] Test coverage > 75% for new code
- [ ] E2E tests for installation flow
- [ ] Security scans on all uploads passing
- [ ] Documentation complete
- [ ] No critical bugs found

### Security âœ…

- [ ] Virus scanning on backend images
- [ ] Security scanning for vulnerabilities
- [ ] Rate limiting on publishing (10/day)
- [ ] Authentication required for admin functions
- [ ] Authorization checks on all endpoints

---

## Implementation Timeline

| Week      | Tasks                   | Hours    | Owner        |
| --------- | ----------------------- | -------- | ------------ |
| 13        | Registry API & Database | 40h      | Backend (1)  |
| 14        | Publishing Workflow     | 40h      | Backend (1)  |
| 15        | Super Admin Marketplace | 40h      | Frontend (2) |
| 16        | Tenant Marketplace      | 40h      | Frontend (2) |
| **Total** | **Complete M2.4**       | **160h** | **3 people** |

---

## Dependencies & Blockers

### External Dependencies

- âœ… M2.1 (Event System) - Completed
- âœ… M2.2 (Module Federation) - Completed
- âœ… M2.3 (Plugin Communication) - Completed

### Infrastructure

- Docker Registry (for backend images)
- CDN or MinIO (for frontend bundles)
- ClamAV or similar (for virus scanning)
- Snyk or similar (for security scanning)

### Team Resources

- 1 Backend Developer (Registry API + Publishing)
- 2 Frontend Developers (Super Admin + Tenant UIs)
- Shared QA for testing

---

## Git Workflow

### Branch Strategy

```bash
# Create feature branch
git checkout -b feature/m2.4-registry

# Work on individual components in sub-branches
git checkout -b feature/m2.4-registry-api
git checkout -b feature/m2.4-publishing
git checkout -b feature/m2.4-marketplace-super-admin
git checkout -b feature/m2.4-marketplace-tenant

# Create PRs for code review
# Merge to main after approval
```

### Commit Messages

```
feat(registry): add plugin registry API with search

- Implement PluginRegistry CRUD operations
- Add full-text search with filters
- Add pagination and sorting
- Add featured plugins endpoint
- Add category listing
- Add registry statistics endpoint

Co-authored-by: Team <team@example.com>
```

---

## Testing Strategy

### Unit Tests (75% coverage target)

- Registry service (search, CRUD, filtering)
- Publishing service (validation, uploads)
- Analytics service (calculations, aggregation)

### Integration Tests

- API endpoints (all 11 endpoints)
- Publishing workflow (upload â†’ scanning â†’ publish)
- Installation flow (registry â†’ install â†’ activate)

### E2E Tests (Playwright)

- Browse marketplace
- Search with filters
- View plugin details
- Install plugin from marketplace
- Submit review

---

## Documentation

### For Developers

- [ ] Registry API documentation (Swagger)
- [ ] Publishing guide with examples
- [ ] Marketplace UI component documentation
- [ ] Database schema documentation

### For Users

- [ ] Plugin publishing guide (20+ pages)
- [ ] Marketplace user guide
- [ ] Plugin versioning best practices
- [ ] Security scanning explanation

---

## Risk Mitigation

| Risk                           | Probability | Impact | Mitigation                                        |
| ------------------------------ | ----------- | ------ | ------------------------------------------------- |
| Search performance issues      | Medium      | Medium | Load test early, optimize queries                 |
| Publishing workflow complexity | High        | Medium | Extensive testing, good error messages            |
| Security scanning failures     | Low         | High   | Have fallback approval workflow                   |
| UI responsiveness issues       | Medium      | Low    | Test on multiple devices, progressive enhancement |
| Rate limiting bypass           | Low         | High   | Strict authentication checks                      |

---

## Known Limitations & Future Work

### M2.4 Scope

- âœ… Basic plugin versioning (semver)
- âœ… Free and paid plugin support
- âŒ Plugin monetization (Stripe integration) â†’ M2.6
- âŒ Plugin upgrade/downgrade paths â†’ M3.0
- âŒ Automated plugin updates â†’ M3.0
- âŒ A/B testing in marketplace â†’ Phase 4

### Future Enhancements (Phase 3+)

- Plugin analytics per tenant
- Advanced recommendation engine
- Plugin bundle creation
- Trial/subscription management
- Plugin development grants program

---

## Glossary

| Term                    | Definition                                          |
| ----------------------- | --------------------------------------------------- |
| **Plugin Registry**     | Central database of available plugins with metadata |
| **Publishing Session**  | Multi-step upload and validation process            |
| **Marketplace**         | UI for discovering and installing plugins           |
| **Plugin Version**      | Specific release of a plugin (e.g., v1.0.0)         |
| **Plugin Installation** | Instance of plugin installed in a specific tenant   |
| **Featured**            | Admin-selected plugins highlighted in marketplace   |
| **Verified**            | Plugins that have passed security scanning          |
| **Review**              | User-submitted rating and feedback                  |

---

_Plexica M2.4 Implementation Plan v1.0_  
_Last updated: January 24, 2026_  
_Next milestone: M2.5 - Kubernetes & Production Deployment_
